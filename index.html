<!DOCTYPE html>
<html>

<head>
  <meta http-equiv='Content-Type' content='text/html' charset='utf-8' />
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Orientable bands</title>
  <!-- <title>M&ouml;bius bands</title> -->
  <link href='utils/3M_favicon.png' rel='icon'>
  <link rel='stylesheet' type='text/css' href='utils/kN.css'>
  <link rel="stylesheet" href='utils/shepherd.css'>
  <script src='utils/babylon.custom.js'></script>

  <script src='utils/util.js'></script>
  <script src='utils/tetToggler.js'></script>
  <script src='utils/global_variable.js'></script>
  <script src='utils/kN3.js'></script>

  <script src='utils/chart.umd.js' defer></script>
  <script src='utils/mathjax_min.js' defer></script>
  <!-- <script src='utils/animated-cursor.js' defer></script> -->

  <script src="https://unpkg.com/animated-cursor@1.1.1/dist/index.umd.js"></script>

  <!-- Shepherd.js JavaScript -->
  <script src='utils/shepherd.js'></script>
  <script src='utils/tour.js'></script>

</head>

<body>
  <!-- <div id="chartLegend" class="chart-legend"></div> -->

  <div class="cursor"></div>
  <script>
    const cursor = document.querySelector('.cursor');

    document.addEventListener('mousemove', e => {
      cursor.setAttribute("style", "top: " + (e.pageY - 10) + "px; left: " + (e.pageX - 10) + "px;")
    })

    document.addEventListener('click', () => {
      cursor.classList.add("expand");

      setTimeout(() => {
        cursor.classList.remove("expand");
      }, 500)
    })

  </script>

  <div class='leftbar'>

  

    <button class='button' id='buttTopologyPlus' title='path traced by a point on the midline
     of the band  during the everting motion'> orientable </button>
     <button class='button' id='buttTopologyMinus' title='path traced by a point on the midline
     of the band  during the everting motion'> nonorientable </button>
     
    <g class="textElement">
    <text  > parameters </text>
    </g>
 
    
    <svg width='200' height='110' viewBox='-100 -55 200 110' style='margin-top:1px'>
      <g class='touchElement glow-effect' id='buttNumOf_n_Minus'>
        <title>decrease n</title>
        <circle cx='-62' cy='10' r='32' /> <!-- Modified cy here -->
        <polygon points='-80 7 -80 13 -44 13 -44 7' fill='#fff' /> <!-- Adjusted y values in points -->
      </g>
      <g class='touchElement glow-effect' id='buttNumOf_n_Plus'>
        <title>increase n</title>
        <circle cx='62' cy='10' r='32' /> <!-- Modified cy here -->
        <polygon points='80 7 80 13 65 13 65 28 59 28 59 13 44 13 44 7 59 7 59 -8 65 -8 65 7' fill='#fff' />
        <!-- Adjusted y values in points -->
      </g>
      <g class="textElement" id='info_n'>
        <text id='infoNumOf_n' y='16'> n=-2 </text>
      </g>
    </svg>
     <br>
     <br>
     
    

    <!-- <div class="inputBox">
      <input type="number" id="alpha_form" min="0" max="1" value="0.25" step="0.005">
    </div> -->

    <br>
    <g class="textElement">
      <text class="textElement" > play/pause </text>
    </g>

    <svg id='playSVG' width='200' height='200' viewBox='-60 -60 120 120' style='margin-top:10px'>
      <g class='touchElement glow-effect' id='buttPlayPause'>
        <title> click to play the everting motion</title>
        <circle cx='0' cy='0' r='20' />
        <polygon id='playPausePoly' points='-7 -10 -7 10 13 0' fill='#fff' />
      </g>
      <g class='touchElement  ' id='clockRing'>
        <title> drag to evert the band</title>
        <circle cx='0' cy='0' r='40' fill='none' stroke='#555' stroke-width='26' />
        <circle id='clockHand' r='10' fill='#fff' />
      </g>
    </svg>

    <svg xmlns="http://www.w3.org/2000/svg" version="1.1" style="height:0; width:0; position:absolute;">
      <defs>
        <filter id="colorful-glow">
          <feGaussianBlur in="SourceGraphic" stdDeviation="3" result="blur" />
          <feOffset in="blur" dx="0" dy="0" result="offsetBlur" />
          <feFlood flood-color="#FF7300" result="flood" />
          <feComposite in="flood" in2="offsetBlur" operator="in" result="colorBlur" />
          <feMerge>
            <feMergeNode in="colorBlur" />
            <feMergeNode in="SourceGraphic" />
          </feMerge>
        </filter>
      </defs>
    </svg>

    <br>
    <g class="textElement">
      <text class="textElement" > speed </text>
    </g>

 
    <svg id='speedSlider' class='slider glow-effect' width='200' height='124' viewBox='-100 -45 200 70'>
      <title> slide to change the speed of eversion</title>
      <text x='-5' y='-10' >speed</text> <!-- Position the text on top -->
      <polygon fill='#555' points='-100 0 -100 40 100 40 100 0' /> <!-- Reposition the polygon -->
      <rect width='38' height='38' x='-19' y='1' /> <!-- Reposition the rectangle -->
    </svg>

       <g class="textElement">
      <text class="textElement" > width </text>
    </g>
    <svg id='hingeLengthSlider' class='slider glow-effect' width='200' height='124' viewBox='-100 -45 200 70'>
      <title> slide to change the width of the band</title>
      <text x='-5' y='-10' >speed</text> <!-- Position the text on top -->
      <polygon fill='#555' points='-100 0 -100 40 100 40 100 0' /> <!-- Reposition the polygon -->
      <rect width='38' height='38' x='-19' y='1' /> <!-- Reposition the rectangle -->
    </svg>

    
     

  </div>

  <div class='rightbar'>
    <button class='button' id='buttFullScreen' title='enable full screen'> full screen </button>
    
   
    <button class='button' id='buttShowMid' title='path traced by a point on the midline
     of the band  during the everting motion'> eversion path </button>
    <button class='button' id='buttShowUnit' title='show 1/n th of the band with n half twists '> show unit </button>
    <!-- <button class='button' id='buttShowAxis'> show axis </button> -->

    <!-- <g class="textElement">

      <text> physics </text>
    </g> -->
    <!-- 
    <button class='button' id="buttShowEnergy"
      title='dimensionless torsion of the midline versus dimensionless bending energy of the stable bands. click on the plot to change the torsion'>
      bending energy</button> -->


    <br>

    <g class="textElement">

      <text> colors </text>
    </g>
    <button class='button' id='buttColor1' title='ranbow color scheme for the surface of the band'> rainbow </button>
    <button class='button' id='buttColor2' title='two faces of the band colored with white and red'> digital </button>
    <!-- <button class='button' id='buttColor3'> M&ouml;bius rainbow 3 </button>
    <button class='button' id='buttColor4'> digital </button>
    <button class='button' id='buttColor5'> M&ouml;bius BRW 3 </button> -->


    <button class='button' id="backgroundButton"
      title='change the background color for the best visibility using picker on the left-top'>background Color</button>
    <input type="color" id="colorPicker" style="display: none;">

    <!-- <input class="jscolor" value="ab2567" data-jscolor="{format:'rgba', position:'right', width:181, height:101}"> -->

    <br>
    <g class="textElement">
      <text> view angle </text>
    </g>
    <button class='button' id='buttAlignAxis' title='align the view with the axis of symmetry'> align axis </button>
    <button class='button' id='buttAlignPlane' title='align the view with the best fit plane'> align plane </button>

  </div>

  <div class="container">
    <div class="content">
      <canvas id='renderCanvas' touch-action='none'></canvas>
      <img src='utils/dragon_oist.svg' style='height:40px;position:absolute;left:0;bottom:0;margin:10px'>
      <img src='utils/3M_white.svg' style='height:40px;position:absolute;right:0;bottom:0;margin:10px'>
    </div>
  </div>
  <div class="contentE">
    <canvas id='renderCanvasE' touch-action='none'></canvas>
    <!-- <canvas id="magnifier"></canvas> -->
  </div>
  <div class="contentK">
    <canvas id='renderCanvasK' touch-action='none'></canvas>
  </div>


  </div>

  <div id="animatedCursor"></div>

  <!-- 
  <div id="tourModal" class="modal-backdrop">
    <div class="modal-content">
      <h2>Welcome!</h2>
      <p>Would you like a guided tour of the application?</p>
      <button id="startTourBtn" class="modal-button">Start Tour</button>
      <button id="dismissTourBtn" class="modal-button">No Thanks</button>
       <p> Press c on the keyboard to interrupt the tour.</p> -->
  <!-- </div>
  </div> -->



  <script>

    var contentE = document.querySelector('.contentE');
    var content = document.querySelector('.content');
    var contentK = document.querySelector('.contentK');
    var contentEWidth = contentE.clientWidth;
    var nChanged = new Event('nChanged'); // triggered by plus/minus buttons
    var energyChanged = new Event('energyChanged'); // triggered by plus/minus buttons
    // var N = 240
    var nu_i;
    var plotClicked;



    'use strict';


    if (document.documentMode || /Edge/.test(navigator.userAgent)) {
      alert('MICROSOFT ALARM: You are using strange software which may lead to unexpected behavior of the website. Please use a reasonable 21st century browser, like, for example: Chrome, Firefox, Opera, Safari,...');
    }


    // adding default-visible class to the left and right bar so that they are visible when the page is loaded

    document.addEventListener('DOMContentLoaded', function () {


const elements = document.querySelectorAll('.leftbar .touchElement, .leftbar .slider, .rightbar .touchElement, .rightbar .slider, .leftbar .button, .rightbar .button,   .rightbar .textElement');
elements.forEach(el => el.classList.add('default-visible'));

setTimeout(() => {
  elements.forEach(el => el.classList.remove('default-visible'));
}, 15000);
});




    window.addEventListener('DOMContentLoaded', function () {
 
 
      var n = 3;
      var N = 200;
      var n_min = 2;
      var n_max = 30;
       
      // Ensure n is defined somewhere in your code. For example:
      var Nmin = 1.5; // Just an example, set it to your desired minimum
      var Nmax = 200;  
      var NStepSize = 1;

      // quantitites for alpha slider 
      var NSlider;
   
  


       ebID('infoNumOf_n').innerHTML = "n = " + n.toString();
      // ebID('alpha_value').innerHTML = "\u03B1 = " + parseFloat(this.value).toFixed(4).toString() + "&pi;";
      // number of twists 
      n = Math.abs(n);

       

      /// initialize the mesh
      var n = 3;
       var c = 10;
      var t = 0;
      var N = 200;
      

      var topology =  -1;

      var showMid = false;
      init_parameters(n,N,topology);
      
       
      animationData(t);
      
      
      ///////////////////////////////////////////////////

      //////// event listeners for the parameters ///////

      function syncValues(source, target) {
        target.value = source.value;
      }

      
    // buttons start here 

     /// n buttons
      // change number of half twists ////////////////////////////////////////////////////

      var orientable = false;
      var nonorientable = false;

      buttonSwitchColor(ebID('buttTopologyMinus'), !nonorientable);

      ebID('buttTopologyPlus').addEventListener('click', function () {

        orientable = true;
        nonorientalbe = false;
        buttonSwitchColor(ebID('buttTopologyPlus'), true);
        buttonSwitchColor(ebID('buttTopologyMinus'), false);

        // checking if number n of half twists is odd
        if(n%2==1){
          n=2;

          ebID('infoNumOf_n').innerHTML = "n = " + n.toString();
        }
        
        
       
        topology = 1;
          

        document.body.dispatchEvent(nChanged);
       
      });

      ebID('buttTopologyMinus').addEventListener('click', function () {

        nonorientable = true;
        orientable = false;
        buttonSwitchColor(ebID('buttTopologyMinus'),true);
        buttonSwitchColor(ebID('buttTopologyPlus'), false);
        
        // checking if number n of half twists is even
        if(n%2==0){
          n=3;
          ebID('infoNumOf_n').innerHTML = "n = " + n.toString();
        }

        topology = -1;
  

        document.body.dispatchEvent(nChanged);

        });


      /// n buttons
// change number of half twists ////////////////////////////////////////////////////
ebID('buttNumOf_n_Minus').addEventListener('click', function () {
  if (n > n_min+1) {
    // Decrement based on topology
    if (topology === 1) {
      // For topology = 1, decrement by 2 (even numbers only)
      n = n - 2;
    } else if (topology === -1) {
      // For topology = -1, ensure we stay on odd numbers
      n = n - 2;
      if (n % 2 === 0) { // If we landed on an even number
        n = n - 1;       // Go one more to get an odd number
      }
    } else {
      // Default behavior for other topology values
      
      n = n - 1;
    }
    
    // Ensure we don't go below minimum
    n = Math.max(n, n_min);
    
    ebID('infoNumOf_n').innerHTML = "n = " + n.toString();
    document.body.dispatchEvent(nChanged);
  }
});

ebID('buttNumOf_n_Plus').addEventListener('click', function () {
  if (n < n_max) {
    // Increment based on topology
    if (topology === 1) {
      // For topology = 1, increment by 2 (even numbers only)
      n = n + 2;
    } else if (topology === -1) {
      // For topology = -1, ensure we stay on odd numbers
      n = n + 2;
      if (n % 2 === 0) { // If we landed on an even number
        n = n + 1;       // Go one more to get an odd number
      }
    } else {
      // Default behavior for other topology values
      n = n + 1;
    }
    
    // Ensure we don't exceed maximum
    n = Math.min(n, n_max);
    
    ebID('infoNumOf_n').innerHTML = "n = " + n.toString();
    document.body.dispatchEvent(nChanged);
  }
});

   
      ///////////////////////////////////////////////////
      ///////////////////////////////////////////////////
      //////// event listener for parameters done ////////
      ///////////////////////////////////////////////////
      ///////////////////////////////////////////////////






      // get the canvas DOM element
      var canvas = ebID('renderCanvas');

      // load the 3D engine
      var engine = new BABYLON.Engine(canvas, true);

      // createScene function that creates and return the scene
      var createScene = function () {
        // create a basic BJS Scene object
        var scene = new BABYLON.Scene(engine);
        scene.useRightHandedSystem = true;
        scene.clearColor = new BABYLON.Color3(0.3254901960784314, 0.396078431372549, 0.3686274509803922);
        // camera Math.PI
        var camera = new BABYLON.ArcRotateCamera('ArcRotateCamera', Math.PI, 0, 1.2, new BABYLON.Vector3.Zero(), scene);
        camera.lowerRadiusLimit = .1;
        camera.upperRadiusLimit = 100;
        camera.wheelPrecision = 100;
        camera.pinchPrecision = 200;
        scene.activeCamera.panningSensibility = 0;
        camera.alpha = 6.185710546084945;
        camera.beta = 1.0989063024750556;
        camera.radius = 3;
        ///////////////////////////////////////////////////////////////////////////////////

        var light = new BABYLON.SpotLight('spotLight', new BABYLON.Vector3(-.0, 1.5, 0), new BABYLON.Vector3(1, 1, 1), Math.PI / 2, .1, scene);
        light.shadowIntensity = 1.0;
        light.shadowBlur = 4;

        // Set the target of the light to be the camera position
        light.setDirectionToTarget(camera.position);
        // light.parent = camera;

        var white = new BABYLON.StandardMaterial('texture1', scene);
        var cyan = new BABYLON.StandardMaterial('texture1', scene);
        var yellow = new BABYLON.StandardMaterial('texture1', scene);
        var red = new BABYLON.StandardMaterial('texture1', scene);
        var trans = new BABYLON.StandardMaterial('texture1', scene);
        white.diffuseColor = new BABYLON.Color3(1, 1, 1);
        cyan.diffuseColor = new BABYLON.Color3(0, 1, 1);
        yellow.diffuseColor = new BABYLON.Color3(1, 1, 0);
        red.diffuseColor = new BABYLON.Color3(1, 0, 0);
        //cyan.wireframe = true;
        trans.alpha = 0.7;

        var bandMat = new BABYLON.StandardMaterial('texture1', scene);

        bandMat.diffuseColor = new BABYLON.Color3(1, 1, 0);
 


        // Create a new standard material 'glass' 
        var glass = new BABYLON.StandardMaterial("glass", scene);

        // Make it transparent
        glass.alpha = 0.045;
        // Give it a high specular power for glossiness
        glass.specularPower = 100;
        // Give it a low diffusivity so it doesn't scatter light
        glass.diffuseColor = new BABYLON.Color3(1, 1, 1, .1);
        // Set its index of refraction to something like glass
        glass.indexOfRefraction = 1.52;

        //scene.clearColor = new BABYLON.Color3(0, 0, 0);
        //scene.createDefaultSkybox(backgroundTexture, true);



        ///////////////////////////////////////////////////////////////////////////////////
        ///////////////////////////////////////////////////////////////////////////////////




        // Set the material of the arrow



        var golf = [];




        var midlineMaterial = new BABYLON.PBRMaterial("tubeMaterial", scene);
        midlineMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Set a dark color for the ground
        //midlineMaterial.specularColor = new BABYLON.Color3(1, 0, 0);; // Disable specular highlights
        midlineMaterial.emissiveColor = new BABYLON.Color4(1, 0, 0, 1);

        var optionsMidline = [];
        var midline = [];

        // rulings 
        var rulingsMaterial = new BABYLON.PBRMaterial("tubeMaterial", scene);
        rulingsMaterial.diffuseColor = new BABYLON.Color3(1, 0, 0); // Set a dark color for the ground
        //midlineMaterial.specularColor = new BABYLON.Color3(1, 0, 0);; // Disable specular highlights
        rulingsMaterial.emissiveColor = new BABYLON.Color4(1, 1, 1, 1);

        var optionsRulings = [];
        var rulings = [];



        function midlineInit() {
          // Update the path
          var initialPath = [];
          for (var i = 0; i < N + 1; i++) {
            initialPath.push(new BABYLON.Vector3(0, 0, 0));
          }

          optionsMidline = {
            path: initialPath, //vec3 array,
            radius: 0.004, // set the radius of the tube
            updatable: true
          };
          // Update the tube mesh with the new data
          midline = BABYLON.MeshBuilder.CreateTube("midline", optionsMidline, scene);
          midline.material = midlineMaterial;

          // initialize rulings 
          

          if(N<22){
            for (var i = 1; i < N + 1; i++) {
            let temp = [];
            temp.push(new BABYLON.Vector3(0, 0, 0));
            temp.push(new BABYLON.Vector3(0, 0, 0));

            optionsRulings = {
              path: temp, //vec3 array,
              radius: 0.01, // set the radius of the tube
              updatable: true
            };

            rulings[i] = BABYLON.MeshBuilder.CreateTube("rulings", optionsRulings, scene);
            rulings[i].material = rulingsMaterial;


          };

          }
          else{
          for (var i = 1; i < n + 1; i++) {
            let temp = [];
            temp.push(new BABYLON.Vector3(0, 0, 0));
            temp.push(new BABYLON.Vector3(0, 0, 0));

            optionsRulings = {
              path: temp, //vec3 array,
              radius: 0.01, // set the radius of the tube
              updatable: true
            };

            rulings[i] = BABYLON.MeshBuilder.CreateTube("rulings", optionsRulings, scene);
            rulings[i].material = rulingsMaterial;


          };
        }

        };
        midlineInit();



 
        var t;



        var eversionPlay = new Event('eversionPlay'); // triggered by plus/minus buttons

        var vertexData = [];
        var vertexDataBack = [];
        var band = new BABYLON.Mesh('custom', scene);
        var bandBack = new BABYLON.Mesh('custom', scene);

        function k_to_t(k) {
          return Math.round(k * N / (2 * Math.PI));
        };
        var t;

        function updateBandMesh(n,N,k, hingeLength,topology) {
          
         t = k_to_t(k)

          let temp = fourierExpansion(n,N, t, hingeLength,topology);
          var v = temp[0];

          // updating curvature 
          kappa = temp[1].concat();
          document.body.dispatchEvent(eversionPlay);


          if (showKappa == true) {
            if (chartK != null) {
              destroyChart(chartK);
            }
            createchartK(kappa);
          }

 
          // N = 105;
          var pos = [];
          var pathMidline = [];
          var indices = [];
          var indicesBack = [];
          var colors = [];
          var colorsBack = [];
          
          var sign_band = topology;
          for (var i = 1; i < N ; i++) {
            var v1 = [v[6 * i - 5], v[6 * i - 3], -v[6 * i - 4]];
            var v2 = [v[6 * i - 2], v[6 * i], -v[6 * i - 1]];



            pathMidline.push(new BABYLON.Vector3((v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2));

            // surface 

            pos.push(v1[0], v1[1], v1[2]);
            pos.push(v2[0], v2[1], v2[2]);

            if (colorScheme == 1) {
              var c1 = jet(i-1,N);;

              colors.push(c1[0], c1[1], c1[2], c1[3]);
              colors.push(c1[0], c1[1], c1[2], c1[3]);
              colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
              colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
            } else {
              colors.push(1, 1, 1, 1);
              colors.push(1, 1, 1, 1);
              colorsBack.push(1, 0, 0, 1);
              colorsBack.push(1, 0, 0, 1);
            }

            
              indices.push(2 * i - 1, 2 * i, 2 * i - 2);
              indices.push(2 * i, 2 * i - 1, 2 * i + 1);

              indicesBack.push(2 * i, 2 * i - 1, 2 * i - 2);
              indicesBack.push(2 * i - 1, 2 * i, 2 * i + 1);

             
          };

            i = N;

          var v1 = [v[6 * i - 5], v[6 * i - 3], -v[6 * i - 4]];
            var v2 = [v[6 * i - 2], v[6 * i], -v[6 * i - 1]];



            pathMidline.push(new BABYLON.Vector3((v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2));

            // surface 

            pos.push(v1[0], v1[1], v1[2]);
            pos.push(v2[0], v2[1], v2[2]);

            if (colorScheme == 1) {
              var c1 = jet(i-1,N);;

              colors.push(c1[0], c1[1], c1[2], c1[3]);
              colors.push(c1[0], c1[1], c1[2], c1[3]);
              colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
              colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
            } else {
              colors.push(1, 1, 1, 1);
              colors.push(1, 1, 1, 1);
              colorsBack.push(1, 0, 0, 1);
              colorsBack.push(1, 0, 0, 1);
            }
             
            if(topology==1){
             
            
              indices.push(2 * i-1, 2 * i + 1, 2 * i- 2 );
              indices.push(2 * i+1,  2 * i - 1,2 * i);

              indicesBack.push(2 * i + 1, 2 * i-1, 2 * i - 2);
              indicesBack.push(2 * i -1, 2 * i +1,2*i  );
           } 
           else {
            
              indices.push(2 * i - 1, 2 * i, 2 * i - 2);
              indices.push(2 * i, 2 * i - 1, 2 * i + 1);

              indicesBack.push(2 * i, 2 * i - 1, 2 * i - 2);
              indicesBack.push(2 * i - 1, 2 * i, 2 * i + 1);
            };
 
         

          //   console.log(pathMidline)
          // Update the tube mesh with the new path
          // Remove the existing tube mesh


          i = 1;
 
            var v2 = [v[6 * i - 5], v[6 * i - 3], -v[6 * i - 4]];
            var v1 = [v[6 * i - 2], v[6 * i], -v[6 * i - 1]];
          

          
          pathMidline.push(new BABYLON.Vector3((v1[0] + v2[0]) / 2, (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2));

          pos.push(v1[0], v1[1], v1[2]);
          pos.push(v2[0], v2[1], v2[2]);

          if (colorScheme == 1) {
            var c1 = jet(i-1,N);;

            colors.push(c1[0], c1[1], c1[2], c1[3]);
            colors.push(c1[0], c1[1], c1[2], c1[3]);
            colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
            colorsBack.push(c1[0], c1[1], c1[2], c1[3]);
          } else {
            colors.push(1, 1, 1, 1);
            colors.push(1, 1, 1, 1);
            colorsBack.push(1, 0, 0, 1);
            colorsBack.push(1, 0, 0, 1);
          }

          // indicesBack.push(2*N-1, 1, 0);
          // indicesBack.push(2*N-1, 0, 2*N);

          //   indices.push( 0,2*N-1, 2*N);
          //   indices.push( 1,2*N-1, 0);


          var normals = [];
          BABYLON.VertexData.ComputeNormals(pos, indices, normals);

          var vertexData = new BABYLON.VertexData();
          vertexData.positions = pos;
          vertexData.indices = indices;
          vertexData.normals = normals;
          vertexData.colors = colors;

          vertexData.applyToMesh(band);



          var normalsBack = [];
          BABYLON.VertexData.ComputeNormals(pos, indicesBack, normalsBack);
          vertexDataBack = new BABYLON.VertexData();
          vertexDataBack.positions = pos;
          vertexDataBack.indices = indicesBack;
          vertexDataBack.normals = normalsBack;
          vertexDataBack.colors = colorsBack;

          vertexDataBack.applyToMesh(bandBack);

          ///  surface created 

          /// creating midline 

          // Update
          optionsMidline.path = pathMidline;
          optionsMidline.instance = midline;
          midline = BABYLON.MeshBuilder.CreateTube("midline", optionsMidline); //No scene parameter when using instance
          //midline = BABYLON.MeshBuilder.CreateTube(null, optionsMidline, scene, midline);
          //midline = BABYLON.MeshBuilder.CreateTube(null, optionsMidline, scene, midline);


          if (showUnit) {
            // Enable vertex alpha for the mesh
            band.hasVertexAlpha = true;
            bandBack.hasVertexAlpha = true;

            // Disable backface culling
            //band.backFaceCulling = false;
            //bandBack.backFaceCulling = false;

            var vertexData = band.getVerticesData(BABYLON.VertexBuffer.ColorKind);
            var vertexDataBack = bandBack.getVerticesData(BABYLON.VertexBuffer.ColorKind);

            // Ensure the vertex buffer is large enough to accommodate the modifications
            if (!vertexData || vertexData.length < 4 * (N + 1)) {
              vertexData = new Float32Array(4 * (N + 1));
            }
            if (!vertexDataBack || vertexDataBack.length < 4 * (N + 1)) {
              vertexDataBack = new Float32Array(4 * (N + 1));
            }

            var ind = Math.round(N / n) + 1;
            for (var i = ind; i < N + 1; i++) {
              var j = 2 * i;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 1;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 2;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;

              j = 2 * i + 3;
              vertexData[4 * j + 3] = 0.1;
              vertexDataBack[4 * j + 3] = 0.1;
            }

            // Update the vertex colors with modified alpha values
            band.setVerticesData(BABYLON.VertexBuffer.ColorKind, vertexData);
            bandBack.setVerticesData(BABYLON.VertexBuffer.ColorKind, vertexDataBack);


          };




          var ind1 = Math.round(N / (2 * n));

          for (var j = 1; j < golf.length + 1; j++) {
            let l = 2 * j * ind1 - 2 * ind1 + 1;
            var v1 = [v[6 * l - 5], v[6 * l - 3], -v[6 * l - 4]];
            var v2 = [v[6 * l - 2], v[6 * l], -v[6 * l - 1]];
            if (golf[j]) {
              golf[j].position = new BABYLON.Vector3((v1[0] + v2[0]) / 2,
                (v1[1] + v2[1]) / 2, (v1[2] + v2[2]) / 2);

            };

          };



          var ind1 = Math.round(N / (2 * n));


          // creating rulings 

          if(N<22){

            for (var i = 1; i < N + 1; i++) {
            // l =  i * ind1   ;
            l = i;
            var v1 = [v[6 * l - 5], v[6 * l - 3], -v[6 * l - 4]];
            var v2 = [v[6 * l - 2], v[6 * l], -v[6 * l - 1]];
            let path = [];
            path.push(new BABYLON.Vector3(v1[0], v1[1], v1[2]));
            path.push(new BABYLON.Vector3(v2[0], v2[1], v2[2]));

            optionsRulings.path = path;
            optionsRulings.instance = rulings[i];
            rulings[i] = BABYLON.MeshBuilder.CreateTube("rulings", optionsRulings); //No scene parameter when using instance


          };

          }
          else{
          for (var i = 1; i < n + 1; i++) {
            // l =  i * ind1   ;
            l = 2 * i * ind1 - 2 * ind1 + 1;
            var v1 = [v[6 * l - 5], v[6 * l - 3], -v[6 * l - 4]];
            var v2 = [v[6 * l - 2], v[6 * l], -v[6 * l - 1]];
            let path = [];
            path.push(new BABYLON.Vector3(v1[0], v1[1], v1[2]));
            path.push(new BABYLON.Vector3(v2[0], v2[1], v2[2]));

            optionsRulings.path = path;
            optionsRulings.instance = rulings[i];
            rulings[i] = BABYLON.MeshBuilder.CreateTube("rulings", optionsRulings); //No scene parameter when using instance


          };}

          // meshDispose(golf) 

        };




        // tube paths /////////////////////////////////////////////////////////////////////

        function createTube(tube, type, hingeLength, color,topology) {
           console.log('entering create tube')
        
          
          var ind0 = Math.round(N / (2 * n));
          for (var i = 1; i < n + 1; i++) {
            var ind = 2 * i * ind0 - 2 * ind0 + 1;

            var curve = paths(n,N, hingeLength, type, ind, topology);

            console.log(curve)
            tube[i] = BABYLON.Mesh.CreateTube('tube', curve, 0.0025, 8, null, null, scene);
            tube[i].material = color;
            golf[i] = BABYLON.MeshBuilder.CreateIcoSphere(
              'ico', { radius: 0.025, subdivisions: 8, flat: false, updatable: false }, scene);
            golf[i].material = red;
            updateBandMesh(n,N,k, hl, topology);

          }

 
          // if (type == 2) { // midpoints get golf
          //   for (var i = 1; i < n + 1; ++i) {
          //     golf[i] = BABYLON.MeshBuilder.CreateIcoSphere(
          //       'ico', { radius: 0.03, subdivisions: 8, flat: false, updatable: false }, scene);
          //     golf[i].material = color;
          //   }
          // updateBandMesh(k, hl);
          // }
        }


        // plane //////////////////////////////////////////////////////////////////////////

        function enablePlane(bool) {


        }


        // dispose mesh ///////////////////////////////////////////////////////////////////

        function meshDispose(me) {
          var i = 1;
          while (me[i]) {
            me[i].dispose();
            i += 1;
          }
        }

        function setSliderPosition(newValue) {
          var slider = ebID("energySlider");
          if (slider) {
            slider.value = newValue; // Set the slider value
            // Trigger any event or function associated with the slider's change
          }
        }

        //#################################################################################
        //#################################################################################
        //  change m, n, and alpha values 







        // show corner/midpoint paths /////////////////////////////////////////////////////

        



        /////////////////////////nui changed////////////////////////////

        /////////////////////////n  changed////////////////////////////

      

        document.body.addEventListener('nChanged', function (e) {
          
           
          midline.dispose();
          meshDispose(rulings);
          midlineInit();
          init_parameters(n,N, topology)

 
          if (showMid) {

            console.log('entering show midlipath')
            meshDispose(tubeMid);
            meshDispose(golf);
            createTube(tubeMid, 2, 0.5 * 3, yellow,topology);
          }

          updateBandMesh(n,N,k, hl, topology);


          refresh = true;
        }, false);


         

        // toggle tetrahedra //////////////////////////////////////////////////////////////

        var tetToggled = new Event('tetToggled'); // triggered by tetTogStar
        document.body.addEventListener('tetToggled', function (e) { refresh = true; }, false);

        var tetTogStar = new TetTogStar('tetTogStar', nMax, tetToggled);

        // play controller ////////////////////////////////////////////////////////////////

        var svg = ebID('playSVG');
        var pt = svg.createSVGPoint();
        var dragging = false;
        var clockRing = ebID('clockRing');
        clockRing.addEventListener('mousedown', startDragMouse, false);
        clockRing.addEventListener('touchstart', startDragTouch, false);
        window.addEventListener('mousemove', dragMouse, false);
        window.addEventListener('touchmove', dragTouch, false);
        window.addEventListener('mouseup', stopDrag, false);
        window.addEventListener('touchend', stopDrag, false);
        function startDragMouse(ev) {
          dragging = true;
          if (play) { playIt() };
          dragMouse(ev);
          clockRing.style.opacity = 1;
        }
        function startDragTouch(ev) {
          dragging = true;
          if (play) { playIt() };
          dragTouch(ev);
          clockRing.style.opacity = 1;
        }
        function dragMouse(ev) {
          if (dragging) {
            pt.x = ev.clientX;
            pt.y = ev.clientY;
            var loc = pt.matrixTransform(svg.getScreenCTM().inverse());
            var angle = Math.atan2(loc.x, -loc.y) % (2 * Math.PI);
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(angle));
            dot.setAttribute('cy', -40 * Math.cos(angle));
            k = angle;
            updateBandMesh(n,N,k, hl, topology);
            refresh = true;
          }
        }
        function dragTouch(ev) {
          if (dragging) {
            pt.x = ev.touches[0].clientX;
            pt.y = ev.touches[0].clientY;
            var loc = pt.matrixTransform(svg.getScreenCTM().inverse());
            var angle = Math.atan2(loc.x, -loc.y) % (2 * Math.PI);
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(angle));
            dot.setAttribute('cy', -40 * Math.cos(angle));
            k = angle;
            updateBandMesh(n,N,k, hl, topology);
            refresh = true;
          }
        }
        function stopDrag() {
          dragging = false;
          clockRing.style.opacity = '';
        }
        // function playIt() {
        //   play = !play;
        //   if (!play) {
        //     ebID('playPausePoly').setAttribute('points', '-25 -40 -25 40 43 0');
        //   }                                 //-7 -10 -7 10 13 0   old size 
        //   else {
        //     ebID('playPausePoly').setAttribute('points', '-31 -40 -31 40 -10 40 -10 -40 14 -40 14 40 35 40 35 -40 -25 -40');
        //   }
        // };

        function playIt() {
          play = !play;
          if (!play) {
            ebID('playPausePoly').setAttribute('points', '-7 -10 -7 10 13 0');
          }
          else {
            ebID('playPausePoly').setAttribute('points', '-7 -10 -7 10 -2 10 -2 -10 2 -10 2 10 7 10 7 -10 -7 -10');
          }
        };

        ebID('buttPlayPause').addEventListener('click', playIt, false);
        document.addEventListener('keydown', function (e) { if (e.keyCode == '32') playIt(); }); // space key play

        // speed control //////////////////////////////////////////////////////////////////

        var speedSlider = new Slider('speedSlider', 4, 50, 20, '', 0, '%');
        ebID('speedSlider').addEventListener('sliderChange', function () {
          speedy = speedSlider.getValue() / 4000 / n ** .2 * N**.2;
        });


        var hingeLengthSlider = new Slider('hingeLengthSlider', 0, 50, hl * 100, '', 0, '%');
        ebID('hingeLengthSlider').addEventListener('sliderChange', function () {
          hl = hingeLengthSlider.getValue() / 100;
          if (!play) updateBandMesh(n,N,k, hl, topology);

          refresh = true;

        });






        // change width/length ////////////////////////////////////////////////////////////


        // ///  modifying sliders during the guiding tour 
        // ebID('speedSlider').addEventListener('tourSpeed', function () {
        //   speedSlider = new Slider('speedSlider', 4, 100, 40, '', 0, '%');
        //   speedy = 40 / 2000 / n ** .2;
        // });

        // ebID('speedSlider').addEventListener('tourSpeedBack', function () {
        //   speedSlider = new Slider('speedSlider', 4, 100, 20, '', 0, '%');
        //   speedy = 20 / 2000 / n ** .2;
        // });


        // ebID('hingeLengthSlider').addEventListener('tourWidth', function () {
        //   hl = 0.4;
        //   hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 40, 'width', 0, '%');

        //   if (!play) updateBandMesh(k, hl);
        //   // if (showCorn) {
        //   //   meshDispose(tubeCorn);
        //   //   createTube(tubeCorn,1,hl,white);
        //   // }
        //   refresh = true;
        // })
        // ebID('hingeLengthSlider').addEventListener('tourWidthBack', function () {
        //   hl = 0.2;
        //   hingeLengthSlider = new Slider('hingeLengthSlider', 0, 100, 20, 'width', 0, '%');

        //   if (!play) updateBandMesh(k, hl);
        //   // if (showCorn) {
        //   //   meshDispose(tubeCorn);
        //   //   createTube(tubeCorn,1,hl,white);
        //   // }
        //   refresh = true;
        // })

        ////////////////////////////////////////////////////////////////

        // toggle full screen /////////////////////////////////////////////////////////////

        // var ortho = false;
        var fullScreen = false;
        ebID('buttFullScreen').addEventListener('click', function () {
          fullScreen = !fullScreen;
          buttonSwitchColor(ebID('buttFullScreen'), fullScreen);
          toggleFullScreen();
          // ortho = !ortho;
          // if ( ortho ) camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;
          // else camera.mode = BABYLON.Camera.PERSPECTIVE_CAMERA;
        });


        // show axis/plane ////////////////////////////////////////////////////////////////





        var showUnit = false;
        ebID('buttShowUnit').addEventListener('click', function () {
          showUnit = !showUnit;
          buttonSwitchColor(ebID('buttShowUnit'), showUnit);





          refresh = true;
        });

        // align to plane/axis ////////////////////////////////////////////////////////////
        var alignPlane = false;
        ebID('buttAlignPlane').addEventListener('click', function () {
          alignPlane = !alignPlane;
          //  buttonSwitchColor(ebID('buttAlignPlane' ), alignPlane);
          camera.alpha = Math.PI;
          camera.beta = Math.PI / 2;
          if (!play) k = 0;
          refresh = true;
        });
        var alignAxis = false;
        ebID('buttAlignAxis').addEventListener('click', function () {
          alignAxis = !alignAxis;
          // buttonSwitchColor(ebID('buttAlignAxis' ), alignAxis);
          camera.alpha = Math.PI;
          camera.beta = 0;
          if (!play) k = 0;
          refresh = true;
        });

        // changing the camera angle during the tour 
        ebID('renderCanvas').addEventListener('tourCamera', function (event) {
          // buttonSwitchColor(ebID('buttAlignAxis' ), alignAxis);
          camera.alpha = event.detail.alpha;
          camera.beta = event.detail.beta;
          if (!play) k = 0;
          refresh = true;
        });

        // change surface colors //////////////////////////////////////////////////////////

        var previousColorScheme = colorScheme;
        buttonSwitchColor(ebID('buttColor' + colorScheme), true);

        for (var i = 1; i < maxColor + 1; i++) {
          (function (i) {
            ebID('buttColor' + i).addEventListener('click', function () {
              previousColorScheme = colorScheme;
              colorScheme = i;
              document.body.dispatchEvent(colorChanged);
            });
          }(i));
        }

        var colorChanged = new Event('colorChanged'); // triggered by plus/minus buttons

        document.body.addEventListener('colorChanged', function (e) {
          buttonSwitchColor(ebID('buttColor' + previousColorScheme), false);
          buttonSwitchColor(ebID('buttColor' + colorScheme), true);
          if (!play) updateBandMesh(n,N,k, hl, topology);
          refresh = true;
        }, false);


        var tubeMid = [];

        
        showMid = !showMid;
          buttonSwitchColor(ebID('buttShowMid'), showMid);
          if (showMid) createTube(tubeMid, 1, 0.5 * 3, yellow,topology);
          else {
            meshDispose(tubeMid);
            meshDispose(golf);
          }
          refresh = true

        ebID('buttShowMid').addEventListener('click', function () {
          showMid = !showMid;
          buttonSwitchColor(ebID('buttShowMid'), showMid);
          if (showMid) createTube(tubeMid, 1, 0.5 * 3, yellow,topology);
          else {
            meshDispose(tubeMid);
            meshDispose(golf);
          }
          refresh = true;
        });
        ///////////////////////////////////////////////////////////////////////////////////

        camera.attachControl(canvas, false);

        function refreshScene() { refresh = true; } // to prevent freezing of the render window after long inactivity
        setInterval(refreshScene, 1000);





        //#############################################################
        //#############################################################
        scene.registerBeforeRender(function () {
          if (play || k == 0) {
            updateBandMesh(n,N,k, hl, topology);
            // move clock hand
            var dot = ebID('clockHand');
            dot.setAttribute('cx', 40 * Math.sin(k));
            dot.setAttribute('cy', -40 * Math.cos(k));
            if (play) k += speedy;
          }
        });
        //#############################################################
        //#############################################################


        // the canvas/window resize event handler
        window.addEventListener('resize', function () { engine.resize(); refresh = true; });

        function rend() {
          scene.render();
        }

        var customRender = function () {
          if (refresh || play ||
            Math.abs(camera.inertialRadiusOffset) > 0 ||
            Math.abs(camera.inertialAlphaOffset) > 0 ||
            Math.abs(camera.inertialBetaOffset) > 0) {
            scene.render();
          }
          if (refresh) refresh = false;
        }
        engine.stopRenderLoop(); // Stop the automatic PG rendering
        rend(); // Render the first frame.
        engine.runRenderLoop(customRender); //start main render loop

        //document.body.addEventListener('nuiChanged', function () { console.log("updated value of nu index is " +  parseInt(nuSlider.getValue()))});
 



        var showEnergy = false;
        var showKappa = false;
        var showEversionPath = false;



        // energy changed during the tour


        ////////////////////////////////////////////////////////////////
        // create the chart for curvature 
        ////////////////////////////////////////////////////////////////




        // creating the plot for paths
        //var curve = paths(n, hingeLength, type, ind);


 

        function positionSliderAbovePlot(slider, chart) {
          var canvasRect = chart.canvas.getBoundingClientRect();
          var chartArea = chart.chartArea;

          var leftOffset = canvasRect.left + chartArea.left;
          var topOffset = canvasRect.top + chartArea.bottom; // Positioning it just below the x-axis
          var width = chartArea.right - chartArea.left;

          slider.style.position = 'absolute';
          slider.style.left = 15 + '%';
          slider.style.top = 23 + '%';
          slider.style.width = width + 'px';
        }


        function addSlider() {
          var canvas = ebID("renderCanvasE");
          var slider = document.createElement("input");
          slider.setAttribute("type", "range");
          slider.setAttribute("id", "energySlider");
          slider.setAttribute("min", "1");
          slider.setAttribute("max", len_ydata.toString());
          slider.classList.add("energySlider");

          document.body.appendChild(slider);
          positionSliderAbovePlot(slider, chart);

          slider.addEventListener("input", function () {

            // deleting the eversion path for efficiently dragging
            meshDispose(tubeMid);
            meshDispose(golf);
            showMid = false;
            buttonSwitchColor(ebID('buttShowMid'), showMid);

            // updated nu value based on the slider
            nu_i = parseInt(this.value);

            // Convert the value from [0, 100] to [8.095, 85.4]

            nui_to_n(nu_i);

            plotClicked = new CustomEvent('plotClicked', { detail: { nu_i: nu_i, n: n } });
            document.body.dispatchEvent(plotClicked);
            ;
          });
        }

        function removeSlider() {
          var slider = ebID("energySlider");
          if (slider) {
            slider.remove();
          }
        }




        // window.addEventListener("resize", function () {
        //   var slider = ebID("energySlider");
        //   var canvas = ebID("renderCanvasE");
        //   if (slider && canvas) {
        //     positionSliderAbovePlot(slider, canvas);
        //   }
        // });





        ////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////


        return scene;
      }

      var scene = createScene(); // call the createScene function

      // Create a custom event
      var openColorPickerEvent = new Event('openColorPicker');


      ebID('backgroundButton').addEventListener('openColorPicker', function () {
        // Trigger the color picker
        ebID('colorPicker').click();
      });

      // Keep the existing 'click' event listener as well
      ebID('backgroundButton').addEventListener('click', function () {
        ebID('colorPicker').click();
      });


      ebID('colorPicker').addEventListener('input', function () {
        // Get the color value from the color picker
        var colorVal = this.value;

        // Convert hex color to RGB
        var r = parseInt(colorVal.substr(1, 2), 16) / 255;
        var g = parseInt(colorVal.substr(3, 2), 16) / 255;
        var b = parseInt(colorVal.substr(5, 2), 16) / 255;

        // Update the scene's background color
        scene.clearColor = new BABYLON.Color3(r, g, b);
      });


    });



    // Start the tour

    // ...add more steps for other buttons...

    // Start the tour
    var showTour = true;
    window.startTour = function () {

      const cursor = document.querySelector('.cursor');
      if (cursor) {
        cursor.style.display = 'block'; // Show the cursor
      }
      window.tour.start();

      if (showTour == false) {
        window.tour.cancel();
      }


    }



    // document.addEventListener('DOMContentLoaded', function () {
    //   // Show the modal
    //   ebID('tourModal').style.display = 'block';
    // });

    // // Start tour when "Start Tour" button is clicked
    // ebID('startTourBtn').addEventListener('click', function () {



    //   window.startTour();
    //   ebID('tourModal').style.display = 'none'; // Hide modal
    // });

    // // Close modal when "No Thanks" button is clicked
    // ebID('dismissTourBtn').addEventListener('click', function () {
    //   ebID('tourModal').style.display = 'none'; // Hide modal
    // });

    // document.addEventListener('keydown', function(event) {
    //   if (event.key === 'c' || event.key === 'C') {
    //     // Stop the tour
    //     if (tour.isActive()) {
    //       tour.cancel(); // or tour.complete();
    //     }

    //     // Hide the cursor
    //     const cursor = document.querySelector('.cursor');
    //     if (cursor) {
    //       cursor.style.display = 'none';
    //     }
    //   }
    // });




  </script>

</body>

</html>
